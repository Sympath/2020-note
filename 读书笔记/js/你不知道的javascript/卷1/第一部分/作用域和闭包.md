### 编译

#### 编译流程

- 分词/词法分析：将字符串代码分解成词法单元（代码块）
  - 词法分析和分词之间的区别：词法单元生成器工作时调用的是有状态的解析规则，则是词法分析
- 解析/语法分析：将词法单元流（数组）生成AST（Abstract Syntax Tree 抽象语法树）
- 代码生成：将AST转换为可执行代码（机器指令）

#### 工作环境

- 引擎：负责整个JavaScript的编译和执行过程
- 编译器：负责词法分析及代码生成等
- 作用域：负责收集并维护所有声明的标识符组成的一系列查询，实施规则以确定代码对标识符的访问权限

#### 举例说明

- eg 1

`var a = 2; `

1. 编译器进行词法单元分析，生成AST
2. 遇到`var a`：询问作用域此变量是否已经存在在同一作用域之下
   1. 已存在則忽略声明
   2. 未存在则在该作用域下进行变量声明
3. 编译器为引擎生成运行时所需的代码。引擎运行时会询问作用域，沿着作用域链向上寻找（LHS查询）a变量
   1. 找到了，执行代码
   2. 未找到，抛出异常
4. 重点总结：声明和赋值是两个阶段的事儿，要区分思考
5. 引出问题：赋值操作中变量查询的方式
   1. LHS：当变量出现在赋值左侧时，为LHS（本质是尝试寻找到变量的容器本身）
   2. RHS：当变量出现在赋值右侧时，为RHS（本质是取到变量的值）

- eg 2

  ```
  function foo(a){console.log(a)}
  foo(2)
  ```

  - 编译器进行词法单元分析，生成AST
  - 引擎对foo进行RHS，询问作用域
    - 存在，再对a进行LHS，进行对形参a的赋值操作
    - 对console进行RHS，作用域回复为“内置对象”
    - 确定log是否为函数，执行时对a再次进行RHS引用，确定a是否发生变化
    - 执行结束

- test 

  ```
  function foo(a){
  	var b = a;
  	return a + b;
  }
  var c = foo(2)
  ```

  - 编译器进行词法单元分析，生成AST
  - 询问作用域，对c进行LHS
  - 对foo进行RHS，执行
    - 对形参a进行LHS，赋值为2
    - 赋值语句中，对形参a进行RHS，对c进行LHS
    - 返回语句中，对a、b进行RHS
  - 总结：LHS：3  RHS：4

#### 区分LHS和RHS的意义

- 在变量未声明情况下，两种行为表现不同
  - RHS时，引擎抛出ReferenceError异常
    - 扩展：如果找到了变量但进行了不合理的操作，则会抛出TypeError
  - LHS时
    - 非严格模式下，会在全局作用域创建该变量，并返回给引擎
    - 严格模式下，引擎抛出ReferenceError异常



### js特点

- 编译结果在分布式系统中不可移植
- 相比其他语言，js在执行前没有大量的时间用于优化
  - 常见优化：JIT