
### Prototype属性

- 体现：[[Get]]操作访问对象上的属性不存在时，就会使用对象的[[prototype]]链
- 终点：`Object.prototype`

- 属性设置与屏蔽

  ```
  myObject.foo = 'bar';
  ```

  1. myObject存在foo属性：直接修改
  2. 不存在
     1. [[prototype]]链被遍历，若还不存在，则直接添加在myObject身上
     2. 若[[prototype]]存在foo
        1. foo是普通数据访问属性并writable为true，则会在myObject上挂载foo，发生屏蔽
        2. 如果writable为false，则赋值语句会被忽略（严格模式下抛出异常）
        3. 如果foo是一个setter，则会执行setter

```js
// 此为第2.2.1类情况
var anotherObject = { a:2 }; 
var myObject = Object.create( anotherObject ); 
anotherObject.a; // 2
myObject.a; // 2
anotherObject.hasOwnProperty( "a" ); // true
myObject.hasOwnProperty( "a" ); // false 
myObject.a++; // 隐式屏蔽！
anotherObject.a; // 2
myObject.a; // 3 
myObject.hasOwnProperty( "a" ); // true
```

### 类

##### 关键点

- js中不存在类
- 函数默认都会有一个名为prototype的共有且不可枚举的属性，指向一个对象（原型对象）

##### 类函数

- 为什么不存在类
  - 类的一大特点是实例化，即复制，每个实例间互不影响；但js中是委托，实例均指向原型对象，原型对象的改变将影响所有实例

### 构造函数

- 不存在构造函数，只存在构造函数调用，即new 执行函数

  ```js
  impl.constructor == Fn   //true
  ```

  - 实际上impl并没有contructor属性，而是Fn.prototype.constructor == Fn，只是impl委托了Fn的原型对象而已



### create的polyfill

```js
if (!Object.create) { 
    Object.create = function(o) { 
        function F(){} 
        F.prototype = o; 
        return new F(); 
    }; 
}
```

