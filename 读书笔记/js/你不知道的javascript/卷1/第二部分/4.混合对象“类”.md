### js继承

##### 混合继承

1. 遍历源对象得到key

2. 判断key在目标对象上是否存在，不存在则赋值（浅拷贝）

   ```js
   function mixin( sourceObj, targetObj ) {
           for (var key in sourceObj) { 
               // 只会在不存在的情况下复制 
               if (!(key in targetObj)) { targetObj[key] = sourceObj[key]; } 
           } 
       return targetObj; 
   }
   ```

##### 寄生继承

1. 目标对象指向源对象的实例

2. 目标对象特有属性处理

3. 对要重载的方法进行【获取引用】-》【强化方法】-》【新方法赋值】

4. 返回目标对象（注意此时没有返回new默认的this指向的新对象）

   ```js
   //“传统的 JavaScript 类”Vehicle 
   function Vehicle() { this.engines = 1; } 
   Vehicle.prototype.ignition = function() { console.log( "Turning on my engine." ); }; Vehicle.prototype.drive = function() { 
       this.ignition(); 
       console.log( "Steering and moving forward!" ); 
   };
   //“寄生类”Car 
   function Car() { 
       // 首先，car 是一个 Vehicle 
       var car = new Vehicle(); 
       // 接着我们对 car 进行定制 
       car.wheels = 4; 
       // 保存到 Vehicle::drive() 的特殊引用 
       var vehDrive = car.drive; 
       // 重写 Vehicle::drive() 
       car.drive = function() { 
           vehDrive.call( this );
           console.log( "Rolling on all " + this.wheels + " wheels!" ); 
           return car; 
       }
       var myCar = new Car();
       myCar.drive();
   ```

   ##### 隐式混入

   1. 在目标对象的初始化方法中通过call执行源对象的初始化方法，改变执行上下文以实现混入

      ```js
      var Something = 
          { cool: function() { 
              this.greeting = "Hello World";
              this.count = this.count ? this.count + 1 : 1; 
          } };
      Something.cool(); 
      Something.greeting; // "Hello World"
      Something.count; // 1 
      var Another = { cool: function() { 
          // 隐式把 Something 混入 
          Another Something.cool.call( this ); } }; 
      Another.cool(); 
      Another.greeting; // "Hello World"
      Another.count; // 1（count 不是共享状态）
      ```

      

### 小结

- 关键要区分js和其他面向对象语言中对类的定义区别

  |        | 传统                                         | js                                       |
  | ------ | -------------------------------------------- | ---------------------------------------- |
  | 实例化 | 类的行为会被复制到实例中                     | 不会自动创建对象的副本                   |
  | 继承   | 类的行为会被复制到实例中                     | 混入模式实现继承，存在对象引用问题       |
  | 多态   | 在继承链的不同层次名称相同但是功能不同的函数 | 显式伪多肽call等方法实现，脆弱且难以维护 |
  | 封装   |                                              |                                          |

  